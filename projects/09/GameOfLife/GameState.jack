/** The game has only three rules, which are the following:
* 1. Any live cell with two or three live neighbors survives.
* 2. Any dead cell with three live neighbors becomes a live cell.
* 3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.
*/

class GameState {
    field Array grid;
    field int rows;
    field int cols;

    constructor GameState new(int setRows, int setCols) {
        var int i;
        let rows = setRows;
        let cols = setCols;
        let grid = Array.new(rows);  // Simulating 2D array as 1D
        let i = 0;
        while (i < rows) {
            let grid[i] = Array.new(cols);  // Create inner arrays for columns
            let i = i + 1;
        }
        do initGrid();
        return this;
    }

    method void initGrid() {
        var int i, j;
        var array tempRow;
        let i = 0;
        while (i < rows) {
            let tempRow = grid[i];
            let j = 0;
            while (j < cols) {
                let tempRow[j] = 0;  // Initialize all cells as dead
                let j = j + 1;
            }
            let i = i + 1;
        }

        // Setting a 'Glider' pattern at the center
        let tempRow = grid[rows / 2 -1];
        let tempRow[cols/2] = 1;
        let tempRow = grid[rows / 2];
        let tempRow[cols / 2 + 1] = 1;
        let tempRow = grid[rows / 2 + 1];
        let tempRow[cols / 2 - 1] = 1;
        let tempRow[cols / 2 ] = 1;
        let tempRow[cols / 2 + 1] = 1;
        return;
    }

    method void update() {
        var Array newGrid, tempRow;
        var int i, j;
        let newGrid = Array.new(rows);
        let i = 0;
        while (i < rows) {
            let newGrid[i] = Array.new(cols);
            let tempRow = newGrid[i];
            let j = 0;
            while (j < cols) {
                let tempRow[j] = computeNextState(i, j);
                let j = j + 1;
            }
            let i = i + 1;
        }
        let i = 0;
        while (i < rows) {
            let tempRow = grid[i];
            do tempRow.dispose();  // Dispose the old rows
            let grid[i] = newGrid[i];  // Point to the updated rows
            let i = i + 1;
        }
        do newGrid.dispose();
        return;
    }

    method int computeNextState(int x, int y) {
        var int liveNeighbors, localNeighbor;
        var Array tempRow;
        var int dx, dy, newX, newY;
        let liveNeighbors = 0;
        let dx = -1;
        while (~(dx > 1)) {
            let dy = -1;
            while (~(dy > 1)) {
                if (~(dx = 0) | ~(dy = 0)) {
                    // Wrap-around logic
                    let newX = modulo(x + dx + rows, rows);
                    let newY = modulo(y + dy + cols, cols);
                    
                    let tempRow = grid[newX];
                    let localNeighbor = tempRow[newY];
                    let liveNeighbors = liveNeighbors + localNeighbor;
                }
                let dy = dy + 1;
            }
            let dx = dx + 1;
        }
        
        let tempRow = grid[x];
        if (tempRow[y] = 1) {
            if ((liveNeighbors = 2) | (liveNeighbors = 3)) {
                return 1;
            } else {
                return 0;
            }
        } else {
            if (liveNeighbors = 3) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    method int getCell(int x, int y) {
        var Array tempRow;
        let tempRow = grid[x];
        return tempRow[y];
    }

    method int rows() {
        return rows;
    }

    method int cols() {
        return cols;
    }

    method int modulo(int dividend, int divisor) {
        var int isDividendNegative;
        
        if (divisor = 0) {
            return 0;
        }

        let isDividendNegative = 0;
        if (dividend < 0) {
            let isDividendNegative = 1;
            let dividend = -dividend;
        }

        if (divisor < 0) {
            let divisor = -divisor;
        }

        while (~(dividend < divisor)) {
            let dividend = dividend - divisor;
        }

        if (isDividendNegative) {
            return -dividend;
        }

        return dividend;
    }

}
